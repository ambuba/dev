*** Resources

- https://github.com/getify/You-Dont-Know-JS
- https://runjs.app/
- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
- http://csbin.io/closures

*** Introduction

- Arrays & lists are sub-types of the object type

*** JS Pillars

- Types/Coercions - Primitive, Converting, Checking Equality 
- Scope/Closure - 
- this/Prototypes

- Primitive types - undefined, string, number, boolean, object, symbol
- Undefined - undeclared or declared but with no assigned value
- Null returns "object" as its type. This is a historical bug in JS that has not been fixed yet.
- NaN - Denotes an invalid numeric operation
- New - instantiates Object(), Array(), Function(), Date(), RegExp(), Error()

- Converting types - string concatenation (number to string)
- Truthy/Falsy - Which values will become falss or ture if we attempt to convert them to Boolean
- Falsy values - "", 0, -0, null, NaN, false, undefined
- Truthy - Everything else
- Conversion can also be implicit. For instance, when comparing 2 values of which one is a number, implicit conversion tries to convert the other value into a number too.
- This way you may not need to explicitly convert the second value into a number first
- This will only work as intended if the types involved in every operation are clear
- Avoid things that are hard/confusing to figure out to the reader

- Checking Equality (== and ===) - Double equals allows coercion (for different types) while triple equals disallows coercion (means types must be the same)
- This means that when dealing with the same types, == and === basically do the same work. The output is the same

*** Scope / Closures

- Scope - Where the JS engine looks for things (Where in memory specifically)
- Undefined - Declared but doesn't have a value
- Undeclared - Never been declared
- Function expression - a function that is assigned to a value (Named/Anonymous)
- Immediately Invoked Functional Expression (IIFE) - (function_name)()
- IIFE allows encapsulation of some behaviours within the block scope
- Block Scoping - Use "let" instead of a "var" within the curly braces to prevent encroschment of variables in the outer scope
- Closure - When a function remembers the variables outside of it, even if you pass that function elsewhere
- Practical uses - Helper functions, iterators and generators, module pattern (preserve stae without poluuting the global namespace), asynchronous JavaScript (persist state)

*** Functions With Memories

- When functions get called, they create a live store of data (local memory/variable environment/state) for that function's execution context
- When the function finishes executing, its local memory is deleted (except for the returned value)
- But what if a function could hold on to live data between executions?
- This would let our function definitions have an associated cache/persistent memory
- It all starts with us returning a function from another function
- P.L.S.R.D => Persistent Lexical Scope Referenced Data (Closure) - Backpack* => Occurs via a hidden property called [[scope]]


*** this/Prototypes

- A function's "this" keyword references the execution context for that call, determined entirely by how the function was called
- A "this" aware function can thus have a different context each time it's called, which makes it more flexible and reusable (dynamic context)
- Prototypes - 
- class {} - Layered on top of prototypes


*** Asynchronous JavaScript

- Promises - Most significant ES6 feature
- Aysnchronicity - makes dynamic web apps possible
- Event Loop - JS triage
- Microtask queue, Callback queue and Web Browser features (APIs)
- JS is ansynchronous since it executes each line/instructions at a time
- JS is single threaded (one command runs at a time)
- JS is synchronously executed (each line runs in the order that the code appears)

- So what if we have  a task accessing Twitter's server to get new tweets that takes a long time?
- Challenge - We want to wait for the tweets to be stored in tweets so that thy are available to run displayTweets on - but no code can run in the meantime
- What if we try to delay a function directly using setTimeout?
- SetTimeout - a builtin function - it's first argument is the function to delay followd by the delay in millisecond (ms)
- Our core JS engine has 3 main parts - Thread of Execution, Memory/Variable Environment, Call Stack

- We need to add some new components - Web Browser APIs/Node background APIs, Promises, Event Loop, Callback/Task queue and micro task queue
- When interacting with a world outside of JS (e.g. Calling Browser APIs - SetTimeout, Fetch, Storage, Sockets etc), we need rules
- All global execution contexts must finish/complete first before any code interacting outside JS
- For callbacks with interactions outside JS, they must remain in the callback queue once completed and wait for the call stack to be empty before they are loaded back
- The feature that makes all this possible is called the Event Loop - It consistently checks whether both the call stack and the callback queue are empty

- ES5 Web Browser APIs With Callback Functions - Problem: Our response data is only available in the callback function (Callback Hell)